---
title: js部分面试总结
date: 2023-3-27 9:31
categories: 面试
---

# 1、原型/原型链详解

在创建一个构造函数的时候，这个函数会默认带上一个prototype属性，而这个属性的值就指向这个函数的原型对象。这个原型对象是用来为通过构造函数创建的实例对象提供共享属性，也就是用来实现基于原型的继承和属性的共享。当我们读取实例对象的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果查不到，就去找原型的原型，一直找到最顶层为止(最顶层就是Object.prototype的原型，值为null)。

所以**通过原型一层层相互关联的链状结构就被称为原型链。**

# 2、闭包详解

定义：闭包是指**引用了其他函数作用域中变量的函数**，通常是在嵌套函数中实现的。

从技术角度上所有js函数都是闭包

从实践角度来看，满足以下两个条件的函数算闭包

1. 即使创建了它的上下文被销毁了，它依然存在
2. 在代码中引用了自由变量

**使用场景**

- 创建私有变量

  vue中data需要的是一个闭包，保证每个data中数据唯一，避免多次引用该组件造成的data共享

- 延长变量的生命周期

  一般函数再函数返回后就会销毁，但闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在的词法环境依然存在，以达到延长变量的生命周期的目的。

**应用**

- 柯里化函数
- 防抖、节流

# 3、this指向问题

在绝大多数情况下，函数的调用方式决定可this的值(运行时绑定)

1. 全局的this在非严格模式下指向window对象，在严格模式下指向undefined
2. 对象的属性方法中的this指向对象本身
3. apply、call、bind可以变更this指向为第一个传参
4. 箭头函数中的this指向它的父级作用域，它自身不存在this

# 4、浏览器事件循环

js代码执行过程中，会创建对应的执行上下文并压入执行上下文栈中。如果遇到异步任务，就会将任务挂起，交给其他线程去处理异步任务，当异步任务处理完后，会将回调结果加到事件队列中。当执行栈中所有任务执行完毕后，就是主线程出于闲置状态时，才会从事件队列中取出排在首位的事件回调结果，并把这个回调加入执行栈中然后执行其中的代码，如此反复，这个过程就被称为事件循环。

事件队列为了宏任务队列和微任务队列，在当前执行栈为空时，主线程会先查看微任务队列是否有时间存在，存在则一次执行微任务队列中的事件回调，直至为任务队列为空；不存在再去宏任务队列中处理。

常见的宏任务有`setTimeout()`、`setInterval()`、`setImmediate()`、I/O操作，用户交互操作，UI渲染

常见的微任务有`promise.then()`、`promise.catch()`、`new MutationObserver`、`process.nextTick()`

**宏任务和微任务的本质区别**

- 宏任务有明确的异步任务需要执行和回调，需要其他异步线程支持
-   微任务没有明确的异步任务需要执行，只有回调，不需要其他异步线程支持

# 5、js中数据在栈和堆中的存储方法

- 基本数据类型大小固定且操作简单，放到栈中存储
- 引用数据类型大小不确定，所以将它们放到堆中，让它们在申请内存的时候自己确定大小
- 这样分开存储可以使内存占用最小。栈的效率高于堆
- 栈内存中变量在执行环境结束后会立即进行垃圾回收，而堆内存中需要变量的所有引用都结束才会被回收

# 6、v8垃圾回收机制

根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同分代采用不同的回收算法

- 新生代采用空间换时间的scavenge算法：整个空间分为两块，变量仅存在其中一块，回收的时候将存活变量复制到另一块空间，不存活的回收掉，周而复始轮流操作
- 老生代用标记清理，遍历所有对象可以访问到的对象，然后将不活的当作垃圾进行回收。回收后避免内存的断层不连续，需要标记清理将活着的对象往内存一段移动，移动之后再清理边界内存

# 7、函数调用的方法

- 普通function直接使用()调用并传参，如`function test(name, age){ return name + age }`
- 作为对象的一个属性方法调用，如：`const obj = { test：function(val)  { return val } }`
- 使用call或apply调用，更改函数this指向，也就是更改函数的执行上下文
- new可以间接调用构造函数生成对象实例

# 8、defer和async的区别

- defer会等待HTML代码完全解析完成，再执行
- async等待js资源下载完成立即执行，会阻塞HTML解析
- 但是无论是defer还是async都只对外部引入文件有效

# 9、浏览器事件机制

DOM事件流分为三个阶段：

- **捕获阶段**：

  事件最开始由不太具体的节点最早接收事件，而最具体的节点最后接收时间，为了让事件到达最终目标之前拦截事件

  例如点击一个div，那么事件触发顺序为：document >>> `<html>` >>> `<body>` >>> `<div>`

- **目标阶段**：

  当事件到达目标节点，事件就进入了目标阶段。事件在目标节点上触发，然后会逆向回流，直到传播至最外层的文档节点。

- **冒泡阶段**：

  事件再目标元素上触发后，会继续随着DOM树一层一层往上冒泡，直到到达最外层的根节点

所有时间都会经历捕获阶段和目标阶段，但有些事件会跳过冒泡阶段，比如元素获取焦点focus和失去焦点blur不会冒泡

## **扩展一**

### e.target和e.currentTarget区别

- `e.target`指向触发事件监听的对象
- `e.currentTarget`指向添加监听事件的对象

以下是代码实例

HTML:

```HTML
<ul>
    <li><span>hello 1</span></li>
</ul>
```

JS:

```js
const ul = document.querySelectorAll('ul')[0];
        console.log(ul);
        ul.addEventListener('click', function(e) {
            console.log(e.target); // 被点击的li
            console.log(e.currentTarget); // 被添加监听事件的ul
        })
```

事件冒泡阶段，e.currentTarget和e.target是不相等的，但是在事件的目标阶段，e.currentTarget和e.target是相等的

**应用**：

e.target可以用来实现事件委托，该原理是通过事件冒泡给父元素添加事件监听，e.target指向引发触发事件的元素

## 扩展二

### addEventListener参数

语法：

```js
addEventListener(type, listener);
addEventListener(type, listener, options || useCapture);
```

- type: 监听事件的类型，如 click，scroll，focus，resize
- listener:必须是一个实现了`EventListener`接口的对象，或者是一个函数，当监听的事件类型被触发时会执行
- options: 指定listener有关的可选参数对象
  - capture：布尔值，表示listener是否在事件捕获阶段传播到`EventTarget`时触发
  - once：布尔值，表示listener添加之后最多调用一次，为true则listener在执行一次后会移除
  - passive：布尔值，表示listener永远不会调用`preventDefault()`
  - signal:可选，`AbortSignal`，当他的`about()`方法被调用时，监听器会被移除
- useCapture：布尔值，默认为false，listener在时间冒泡阶段结束时执行，true则表示在捕获阶段开始时执行。作用就是更在事件作用的时机，方便拦截/不被拦截
