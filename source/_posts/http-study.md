---
title: HTTP基础与流程
date: 2022-12-4 12:33
categories: HTTP协议
---

# 一、什么是HTTP协议

HTTP是Hyper Text Transport Protocol的缩写，望文知意便是超文本传输协议。

# 二、HTTP协议能做什么

首先我们知道，我们在使用网页浏览器(web browser)时候的流程，我们首先在浏览器中的地址栏中输入URL（Uniform Resource Locator 统一资源定位符 简单来说是网址），浏览器根据URL从web服务器端获取文件资源，从而显示出web页面。

在上面过程中web使用的协议规范就是HTTP，协议就是规则的约定。

我们把用过发送请求达到获取服务器资源的web浏览器称为客户端（client）。将web类比于现实生活，发送请求以获取资源的就是顾客（客户端），提供资源的就是服务员（服务器端）。

总而言之，HTTP就是负责在客户端请求资源，在服务器端响应的协议。



# 三、与HTTP密切相关的其他协议

在实际生活中，我们要使用HTTP协议就少不了其他的协议的辅助。

## **1、负责传输的IP协议**

IP（Internet Protocol）即网关协议。可能有人会把IP和IP地址搞混，IP的作用是把数据准确传递给对方，而要达到准确转递给对方的目的则需要用到IP地址。IP地址是指明了节点在网络中被分配的地址，因此IP地址可以看做是IP协议完成的一个条件。

## **2、负责传输可靠性的TCP协议**

TCP（transport control protocol）即传输控制协议。它提供可靠的字节流服务。字节流服务是指为了传输方便，将大块的数据分割为文段为单位的数据包进行传输，可靠的传输服务是指能够确定数据包是否发送到对方。

那么如何确定呢

TCP协议采用了**三次握手策略（three-way handshaking）**

### **第一次握手**

建立连接时，客户端向服务器发送SYN报文（SEQ=X,SYN=1），并进入SYN_SENT状态，等待服务器确认。

### **第二次握手**

实际上是分两部分来完成的，即SYN+ACK（请求和确认）报文。

- 服务器收到客户端的请求，向客户端回复一个确认信息（ACK=x+1）。
- 服务器再向客户端发送一个SYN包（SEQ=y）建立连接的请求，此时服务器进入SYN_RECV状态。

### **第三次握手**

是客户端收到服务器的回复（SYN+ACK报文）。此时客户端也要向服务器发送确认包（ACK）。此包发送完毕客户端和服务器进入ESTABLISHED状态，完成三次握手。

注：SEQ表示请求序列号，ACK表示确认序列号，SYN和ACK为标志位。

## **3、负责域名解析的DNS**

DNS即（Domain name system）

上文说到确定主机在互联网中的位置，可以由IP地址确定，而IP地址是一串无规则的数字这并不适合让人类来记忆，相比于无规律的数字人类更倾向于用字母和数字的组合（主机名或者域名）来记忆，DNS的作用就是将域名转换成对应的IP地址，或者将IP地址转换为对应的域名。

## **4、在HTTP工作时，其他协议的职责**

- HTTP协议的职责是生成对目标服务器的请求报文
- DNS的职责将域名转换为对应的IP地址
- TCP协议的职责为了通信方便将HTTP请求报文按序号分为多个报文段，并保证每个报文段可靠的传给对方。传输过后再接收报文段并把报文段按序号组装起来。
- IP协议的职责，搜索对方的地址，进行数据传输。

# **四、HTTP状态码**

- **1XX**：消息状态码
- **2XX**：成功状态码
- **3XX**：重定向状态码
- **4XX**：客户端错误状态码
- **5XX**：服务端错误状态码

## **1XX**

### 100

continue继续。客户端应继续其请求。

### 101

切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议

## 2XX

### 200

OK请求成功，一般用于GET与POST请求

## 3XX

### 301

永久移动。请求的资源已经被永久移动到新的URL，返回的信息会包括新的URL，浏览器会自动定向到新URL。今后的任何请求都应该继续使用原有URL代替

### 302

临时移动。与301类似，但是资源只是临时被移动，客户端应继续使用原有URL

## 4XX

### 401

表示认证失败，场景为token失效，token缺失，token伪造等等

### 403

表示授权失败，通常表示用户通过了身份验证，但缺少权限对给定的资源进行访问或者操作，场景为用户登录成功，但是无权进行读写操作

### 404

服务器无法根据客户端的请求找到资源。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面

### 405

客户端请求中的方法被禁止

## 5XX

### 500

服务器内部错误，无法完成请求。

# 五、HTTP各版本的分述

## 1.HTTP/0.9

HTTP是基于TCP/IP协议的应用层协议。它不涉及数据包的传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。

最早版本是1991年发布的0.9版本。该版本简单到只有一个命令`GET`

```http
GET/index.html
```

上面的命令表示，TCP连接建立后，客户端向服务器请求一个网页`index.html`。

协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式，距离代码如下：

```html
<html>
	<body>Hello World</body>
</html>
```

服务器发送完毕，就会关闭TCP连接

## 2.HTTP/1.0

### 2.1简介

1996年5月，HTTP/1.0发布，内容大大增加。

首先，任何格式的内容都可以发送。这使得互联网不仅可以传输数字，还能传输图像、视频、二进制文件。这位互联网的发展奠定了基础。

其次，除了`GET`命令，还引入了`POST`和`HEAD`命令，丰富了浏览器与服务器交互的手段。

再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息(HTTP header)，用来描述一些元数据。其他新增的功能还包括状态码(status code)、多字符集的支持，多部分发送、权限、缓存、内容编码等。

### 2.2请求格式

下面是一个1.0版的HTTP请求的例子

```http
GET/HTTP/1.0
User-Agent: Mozilla/5.0（Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
```

可以看到此时的格式和0.9版已经有很大的变化了。第一行是请求命令，必须在尾部添加协议版本(HTTP/1.0)。后面就是多行头信息，描述客户端的情况。

### 2.3回应格式

服务器的回应如下

```http
HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>
```

回应的格式是"头信息+一个空行(\r\n)+数据"。其中，第一行是"协议版本+状态码(status code)+状态描述"

### 2.4Content-Type字段

关于字符的编码，1.0版规定，头信息必须是ASCII码，后面的数据可以是任意格式。因此，服务器回应的时候。必须告诉客户端数据是什么格式，这就是`Content-Type`字段的作用。

下面是常见的一些`Content-Type`字段的值

> - text/plain
> - text/html
> - text/css
> - image/jpeg
> - image/png
> - image/svg+xml
> - audio/mp4
> - video/mp4
> - application/javascript
> - application/pdf
> - application/zip
> - application/atom+xml

这些数据类型总称为`MIME type`，每个值包括一级类型和二级类型，之间用斜杠分隔。

除了预定义类型，厂商也可以自定义类型。

```http
application/vnd.debian.binary-package
```

上面的类型表明，发送的是Debian系统的二进制数据包。

`MIME type`还可以在尾部使用分号，添加参数。

```http
Content-Type: text/html; charset=utf-8
```

上面的类型表明，发送的是网页，并且编码是UTF-8。

客户端请求的时候，可以使用`Accept`字段声明自己可以接受哪些数据格式。

```http
Accept: */*
```

上面代码中，客户端声明自己可以接受任何格式的数据。

`MIME type`不仅用在HTTP协议，还可以用在其他地方，比如HTML网页

```html
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<!-- 等同于 -->
<meta charset="utf-8" /> 
```

### 2.5Content-Encoding字段

由于发送的数据可以是任意格式，因此可以把数据压缩之后再发送。`Content-Encoding`字段说明数据的压缩方法。

```http
HTTP/1.0 200 OK
Content-Encoding: gzip
Content-Encoding: compress
Content-Encoding: deflate
```

客户端在请求时，用`Accept-Encoding`字段说明自己可以接收哪些压缩方法

```http

Accept-Encoding: gzip,deflate
```

### 2.6缺点

HTTP/1.0版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。TCP连接的新建成本很高，因为需要客户端和服务器的三次握手，并且开始时发挥速率较慢。所以HTTP/1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。

为了解决这个问题，有些浏览器在请求时用了一个非标准的`Connection`字段

```http

Connection：keep-alive
```

这个字段要求服务器不要关闭TCP连接，以便其他请求服用，服务器同样回应这个字段。一个可以复用的TCP连接就建立了，直到客户端或者服务器主动关闭连接。但是这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。

## 三、HTTP/1.1

1997年1月，HTTP/1.1版本发布，只比1.1版本完了半年。它进一步完善了HTTP协议，一直用到了20年后的今天，直到现在还是最流行的版本。

### 3.1持久连接

1.1版的最大变化，就是引入了持久连接，即TCP默认不关闭，可以被多个请求复用，不用声明`Connection: keep-alive`。

客户端和服务器发现对方一段时间没有活动，就可以关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送`Connection: close`，明确要求服务器关闭TCP连接

```http

Connection: close
```

目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。

### 3.2管道机制

1.1版引入了管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。

举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发送b请求。管道机制则是允许浏览器同时发送A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。

### 3.3Content-Length字段

一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是`Content-Length`字段的作用，声明本次回应的数据长度。

```http

Content-Length: 3495
```

上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。

在1.0版本中，`Content-Length`字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了

### 3.4分块传输编码

使用`Content-Length`字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。

对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用"流模式"取代"缓存模式"。

因此，1.1版规定可以不适用`Content-Length`字段，而使用"分块传输编码"。只要请求或回信的头信息有`Transfer-Encoding`字段，就表明回应将由数量未定的数据块组成

```http

Transfer-Encoding: chunked
```

每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为O的块，就表示本次回应的数据发送完了。下面是一个例子:

```HTTP
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

25
This is the data in the first chunk

1C
and this is the second one

3
con

8
sequence

0
```

### 3.5其他功能

1.1版还新增了许多动词方法：`PUT`、`PATCH`、`HEAD`、`OPTIONS`、`DELETE`。

另外，客户端请求的头信息新增了`Host`字段，用来指定服务器的域名。

```http

Host: www.example.com
```

有了`Host`字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。

### 3.6缺点

虽然1，1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会产生许多请求排队等着。这称为"队头阻塞"

为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。

## 四、SPDY协议

2009年，谷歌公开了自行研发到的SPDY协议，主要解决了HTTP/1.1效率不高的问题。

这个协议在Chrome浏览器上证明可行以后，就被HTTP/2的基础，主要特性都在HTTP/2之中得到继承。

## 五、HTTP/2

2015年，HTTP/2发布。它不叫HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个版本将是HTTP/3。

### 5.1二进制协议

HTTP/1.1版的头信息肯定是文本(ASCII编码)，数据体可以是文本，也可以是二进制。HTTP/2则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧

二进制协议和一个好处是，可以定义额外的帧。HTTP/2定义了近十种帧，为将来更高级的应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。

### 5.2多工

HTTP/2复用TCP连接，在一个链接里，客户端和浏览器都可以同时发送多个请求和回应，而且不用按照顺序一一对应，这样就避免了"队头阻塞"。

举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分，接着回应B请求，完成后，再发送A请求剩下的部分。这样双向的、实时的通信，就叫做多工。

### 5.3数据流

因为HTTP/2得数据包是不按顺序发送的，同一个连接里面连续得数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。HTTP/2将每个请求或回应得所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。

数据流发送到一半的时候，客户端和服务器都可以发送信号，取消这个数据流。1.1版取消数据流的唯一方法就是关闭TCP连接。这就是说，HTTP/2可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。

客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

### 5.4头信息压缩

HTTP协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如`Cookie`和`User Agent`，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

HTTP/2对这一点进行了优化，引入了头信息压缩机制。一方面，头信息使用`gzip`或`compress`压缩后再发送；另一方面客户端和服务器同时维护一张信息表，所有字段都会存入这个表，生成一个索引号，这样就会发送同样字段了，只发送索引号，这样就提高速度了。

### 5.5服务器推送

HTTP/2允许服务器未经请求，主动向客户端发送资源，这叫服务器推送。

常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。
