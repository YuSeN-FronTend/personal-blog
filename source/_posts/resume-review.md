---
title: 重要知识点复习
date: 2023-6-16 9:55
categories: 面试
---
# vue源码部分

## 模板编译

大体的结构分为三个部分：

- 先将模板字符串转换为抽象语法树(解析器)

  这里需要创建一个parse函数来完成对模板字符串的解析，通过正则表达式来抓取标签的开始和结束，将模板字符串转换为一个js对象，方便后续操作。

- 对抽象语法树进行静态节点标记，主要用来做虚拟DOM的优化(优化器)

  对抽象语法树添加属性，一定要添加key，因为再之后的diff算法比较时，可以更加快速且清晰的找到相同的节点，且判断是否需要改变

- 使用抽象语法树生成render函数代码字符串(代码生成器)

  将标记过后的语法树按照规则进行拼接即可

## 响应式原理

在响应式原理中，`Observe`、`Dep`、`Watcher`这三类是构成完整原理的主要成员。

- Observe

  响应式原理的入口，根据数据类型处理观测逻辑。(如果是基本数据类型，即可直接处理，如果是数组或者对象，则可能需要遍历递归处理)

- Dep

  依赖收集器，属性都会有一个Dep，方便发生变化时能够找到对应的依赖触发更新

- Watchar

  用于执行更新渲染，组件会拥有一个渲染Watcher，上面Dep是依赖收集器，收集的就是Watcher

### Observe包含的功能

- 为观测的属性添加`__ob__`，它的值相当于this，即当前`Observe`实例
- 为数组添加重写数组方法，比如: `push`、`unshift`、`splice`等方法，重写目的是在调用这些方法时，进行更新渲染。
- 观测数组内的数据，`observe`内部会调用`new Observe`形成递归观测
- 观测对象数据，Object.defineProperty为数据定义getter或者setter，即数据劫持

### Dep包含的功能

- 数据收集依赖的主要方法，Dep.target是一个watcher实例

- 添加watcher到数组中，也就是添加依赖
- 属性在变化时会调用notify方法，通知每一个依赖进行更新
- Dep.target用来记录watcher实例，是全局唯一的，主要目的是为了在收集依赖的过程中找到对应的watcher

### Watcher包含的功能

- watcher存储dep，dep也存储watcher，进行双向记录
- 触发更新，每次数据发生更改都会通知watcher来进行数据更新

### 大体流程

数据在初始化的时候会通过`observe`来调用`Observe`，初始化时observe拿到的参数data就是我们在data参数内返回的对象。observe只对object类型数据进行观测，观测过的数据都会被添加上`__ob__`属性，通过判断该属性是否存在，防止重复观测。创建Observe实例，开始处理观测逻辑。进入到Observe内部，由于初始化的是一个对象，则在defineReactive中使用Object.defineProperty，这里defineReactive只是一个函数的名字，不是API。如果是对象，则需要调用observe进行递归观测，这里的dep就是上面讲到的每一个属性都会有一个dep，它作为闭包存在，负责收集依赖和更新。在依赖收集时，会先对name属性定义get和set，然后初始化会执行一次watcher.run执行页面，获取data.name，触发get收集依赖，当修改data.name，触发set函数，调用run更新视图。所以在vue3中使用Proxy代替Object.defineProperty也就不足为奇了，因为属性是对象类型的话，递归观测是很消耗性能的，而proxy代理的是整个对象，只要属性发生变化就会触发回调。

## 虚拟DOM和diff算法

虚拟DOM其实就是模板编译，将DOM结构的字符串转换为一个vnode对象来模拟DOM节点。

### diff算法

将虚拟DOM转化成DOM就需要经过diff算法来检测是否是同一节点，如果是则不需要重新生成，这样就会提升页面性能，当项目庞大起来，只更改一个text造成页面重新渲染，这对性能消耗无法想象。所以diff算法的思想和实施是非常有必要的，具体分为几下几点情况。

- 如果oldVnode和newVnode不是同一个节点(同一个sel)，删除旧的，插入新的。

- 如果是同一个节点，还需要分为以下情况

  - 如果是同一个对象没什么都不做

  - 如果newVnode和oldVnode中都有text属性且相等，什么都不做。如果不相等就用新节点text来替换老节点的text

  - 如果老节点没有children而新节点有，则删除老节点的text并添加新节点的children

  - 如果老节点有children，新节点也有，则才真正的用到了diff算法。

    diff算法分为四种情况，设立四个指针，新前、新后、旧前、旧后，按照以下的规则比较移动指针或插入节点。

    - 新前和旧前

      如果相等，新前和旧前同时下移

    - 新后和旧后

      如果相等，新后和旧后同时上移

    - 新后和旧前

      如果相等，新后指向的节点插入到旧后之后，旧前所指向的对应节点变为undefined，新后上移，旧前下移

    - 新前和旧后

      如果相等，新前指向的节点插入到新前之前，旧后所指向的对应节点变为undefined，新前下移，

    如果是旧节点先循环完毕，则新节点剩余的就是需要添加的节点，如果新节点先循环完毕，则老节点剩余的就是需要删除的节点。

    按照如上顺序依此比较，如果都不满足，则需要循环去比较newVnode和oldVnode的剩余节点，但出现的概率不大。

