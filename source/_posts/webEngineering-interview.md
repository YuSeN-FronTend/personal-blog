---
title: 前端工程化和js设计模式面试总结
date: 2023-3-31 9:07
categories: 面试
---
# 前端工程化
## webpack的执行流程和生命周期

webpack是为现代js应用提供静态资源打包功能的bundle

核心流程有三个阶段：初始化阶段，构建阶段和生成阶段。具体如下：

1. 初始化阶段会从配置文件、配置对象和Shell参数中读取初始化的参数并与默认配置结合成最终的参数，以及创建compiler编译器和初始化它的运行环境。
2. 构建阶段编译器会执行它的run()方法开始编译的过程，其中会确认entry入口文件，从入口文件开始搜索与入口文件有直接或者间接关联的所有文件创建依赖对象，之后再根据依赖对象创建module对象，这时候会使用loader将模块转换标准的js内容，，再调用js的解释器将内容转换成AST对象，再从AST中找到该模块依赖的模块，递归本步骤直到所有入口依赖文件都经过本步骤处理。最后完成模块编译，得到了每个模块被翻译的内容和他们之间的关系依赖图，这个依赖图就是项目所有用到的模块的映射关系。
3. 生成阶段会将编译后的module组合成chunk，再把每个chunk转换成一个单独的文件输入到文件列表，确定好输入内容后，再根据配置确定输出路径和文件名，就把文件内容写入文件系统。

## webpack的plugin和loader

- **loader**

  webpack只能理解js和json文件，loader本质上就是个转换器，能将其他类型的文件转换成webpack识别的东西。

  loader会在webpack的构建阶段将依赖对象创建的module转换成标准的js内容的东西。比如vue-loader将vue文件转换为js模块，图片字体通过url-loader转换成data URL，这些webpack能够识别的东西

  可以在module.rules中配置不同的loader解析不同的文件

- **plugin**

  插件本质是一个带有apply的类`class myPlugin { apply(compiler) {} }`，这个apply函数有个参数compiler是webpack初始化阶段生成的编译器对象，可以调用编译器对象中的hooks注册各种钩子的回调这些hooks是贯穿整个编译的生命周期。所以开发者可以通过钩子回调在里面插入特定的代码，实现特定的功能。

  比如stylelint plugin可以指定stylelint的需要检查文件类型和文件范围；HtmlWebpackPlugin用来生成打包后的模板文件；MiniCssExtactPlugin会将所有的css提取成独立的chunks，stylelintplugin可以再开发阶段提供样式的检查功能。

## webpack的hash策略

MiniCssExtactPlugin对于浏览器来说，一方面期望每次请求页面资源时，获得的都是最新的资源；一方面期望在资源没有变化时，复用缓存对象。这个时候，使用文件名+文件哈希值的方式，就可以实现只要通过文件名，就可以区分资源是否有更新。而webpack就内置了hash计算方式，对生成文件的可以在输出文件中添加hash字段

webpack的内置hash有三种

- **hash**

  项目每次构建都会产生一个hash，和整个项目有关，项目任意地方有改变就会改变，hash会根据每次工程的内容进行计算，很容易造成不必要的hash变更，不利于管理，一般来说，没有什么机会直接使用hash

- **content hash**

  和单个文件的内容相关。指定文件的内容发生改变，hash改变，否则不变。对于css文件来说，一般会使用MiniCssExtactPlugin将其抽取为一个单独的css文件。此时可以使用contenthash进行标记，确保css文件内容变化时，可以更新hash

- **chunk hash**

  和webpack打包生成的chunk相关。每一个entry，都会有不同的hash。一般来说，针对于输出文件，我们使用chunkhash。因为webpack打包后，最终每个entry文件及其依赖都会生成单独一个js文件。此时使用chunkhash能够保证整个打包内容的更新准确性。

## vite原理

vite主要由两部分组成：

- 开发环境

  vite利用浏览器去解析imports，在服务器端按需编译返回，完全跳过了打包这个概念。服务器随起随用（相当于把开发的文件转换成ESM格式直接发送给浏览器）。当浏览器 `import HelloWorld from './components/HelloWorld.vue'`时，会向当前域名放松一个请求获取对应的资源，浏览器直接下载对应的文件然后解析成模块记录。然后实例化为模块分配内存，按照导入导出语句建立模块和内存的映射关系。最后运行代码。

  vite会启动一个koa服务器拦截服务器对ESM的请求，通过请求路径找到目录下对应的文件并处理成ESM格式返回给客户端

  vite的热更新是在客户端和服务端建立了websocket链接，代码修改后服务端发送消息通知客户端去请求修改模块的代码，完成热更新。就是改了哪个view文件就重新请求那个文件，这样保证了热更新速度不受项目大小的影响。

  开发环境会使用esbuild对依赖进行预构建缓存，第一次启动会慢一点，后面的启动会直接读取缓存

- 生产环境

  使用rollup来构建代码，提供指令可以用来优化构建过程。缺点就是开发环境和生产环境可能不一致。

## webpack和vite的对比

- webpack的热更新原理就是，一旦发生某个依赖改变，就将这个依赖所处的module更新，并将新的module发送给浏览器重新执行。每次热更新都会重新生成bundle。试想如果依赖越来越多，就算只修改一个文件，理论上热更新的速度也会越来越慢
- vite利用浏览器去解析imports在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用，热更新是在客户端和服务端之间建立了websocket连接，代码修改后服务端发送消息通知客户端去请求修改模块的代码来完成热更新。就是改了哪个文件就重新请求那个文件，这样保证了热更新不受项目大小的影响。

vite目前最大亮点在于开发体验上，服务启动快、热更新快，明显地优化了开发者体验，生产环境底层rollup，rollup更适合小的代码库，从扩展合功能上都不如webpack，可以使用vite作为一个开发服务器的dev server使用，生产打包用webpack这样的模式

## 做过的webpack优化

- 升级webpack版本，3升4，实测是提升了几十秒的打包速度
- splitChunksPlugin抽离公用模块输入单独的chunks，像一些第三方的依赖库，可以单独拆分出来，避免单个chunks过大
- DllPlugin作用同上，这个依赖库相当于从业务代码中剥离出来，只有依赖库自身版本变化才会重新打包，提升打包速度
- loaders的运行是同步的，同各模块会执行全部的loaders

## npm run 执行过程

- 在package.json文件中可以定义script配置项，里面可以定义运行脚本的键和值
- 在npm install 的时候，npm会读取配置将执行脚本软链接到node_modules/.bin目录下，同时将./bin加入到环境变量$PATH中，所以如果在全局直接运行该命令回去全局目录里找，可能会找不到该命令就会报错。比如npm run start，他是执行webpack-dev-server带上参数
- 还有一种情况，就是单纯的执行脚本命令，比如`npm run build`，实际运行的是 node build.js，即使用node执行build.js这个文件

## ESM和CJS的区别

#### ESM

- ES6模块是引用，重新赋值会编译报错，不能修改其变量的指针指向，但可以改变内部属性的值
- ES6模块中的值属于动态只读引入
- 对于只读来说，即不允许修改引入变量的值，import的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到import命令时，就会生成一个只读引用，等到脚本真正执行时，再根据这个只读引用，到被加载的哪个模块里面去取值。
- 对于动态来说，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型
- 循环加载时，ES6模块是动态引用。只要两个模块之间存在某个引用，代码就能够执行。

#### CommonJS

- CommonJs模块是拷贝(浅拷贝)，可以重新赋值，可以修改指针指向；
- 对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值
- 对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。当使用require命令加载某个模块时，就会运行某个模块的代码。
- 当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，commonJS无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行结果，除非手动清除系统缓存。
- 当循环加载时，脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载“，就只输出已经执行的部分，还未执行的部分不会输出

# 设计模式

## 代理模式

定义：为对象提供一个代用品或占位符，以便控制对它的访问

例如要实现图片懒加载功能，可以通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面

## 装饰者模式

定义：在不改变对象自身的基础上，在程序运行期间给对象动态的添加方法

通常运用在原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求

像ts的装饰器就是一个典型的装饰者模式，还有vue中的mixin

## 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。

比如ice stark的子应用，一次只保证渲染一个子应用

## 观察者模式和发布订阅模式

- 两种模式都存在订阅者和发布者，但是观察者模式是由集体目标调度的，而发布/订阅模式是统一由调度中心调的，所以观察者模式的订阅者与发布者之间是存在依赖的，而发布/订阅模式则不会
- 这两种模式都可以用于松散耦合，改进代码管理和潜在的复用
- 在观察者模式中，观察者是知道Subject的，Subject已知保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信
- 观察者模式大多数时候是同步的，比如当时间触发，Subject就会调用观察者方法。而发布-订阅模式大多数时候是异步的(使用消息队列)
