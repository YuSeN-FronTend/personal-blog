---
title: 浏览器和网络面试总结
date: 2023-3-30 8:09
categories: 面试
---

# 跨页面通信的方法

跨页面通信分为同源页面和不同源页面的通信

**不同源页面**可以使用`iframe`作为一个桥梁，因为`iframe`可以指定`origin`来忽略同源限制，所以可以再每个页面都嵌入同一个`iframe`然后监听`iframe`中传递的`message`就可以了

同源页面大致分为三种：广播模式、共享存储模式和口口相传模式

- 广播模式

  就是通过`BroadCast Channel`、`Service Worker`或者`localStorage`作为广播，然后去监听广播事件中消息的变化，达到页面通信的效果

- 共享存储模式

  可以通过`Shared Worker`或者`indexedDB`，创建全局共享的数据存储，然后再通过轮询去定时获取这些被存储的数据是否有变更，达到一个通信效果。例如`cookie`也可以作为实现共享存储达到页面通信的一种方式

- 口口相传模式

  再使用`window.open`的时候，会返回被打开页面的window的引用，而被打开的页面可以通过`window.opener`获取打开它的页面的window的引用，这样多个页面之间的window是可以相互获取到的，传递消息的话通过`postMessage`去传递再做一个事件监听就可以了

# 详解HTTP缓存

在浏览器第一次发起请求服务的过程中，会根据响应报文中的缓存标识决定是否缓存结果，是否将缓存标识和请求结果存入到浏览器缓存中。

HTTP缓存分为强制缓存和协商缓存

**强制缓存**就是请求的时候浏览器向缓存查找这次请求的结果，这里分了三种情况，没查找到直接发起请求(和第一次请求一致)；查找到了并且缓存结果还没有失效，就直接使用缓存结果；查找到了但是缓存结果失效了就会使用协商缓存。

**协商缓存**就是强制缓存的缓存结果失效了，浏览器携带缓存标识向服务器发起请求，有服务器通过缓存标识决定是否使用缓存的过程

# 输入URL到页面展现的全过程

用户输入一段内容后，浏览器会先去判断这段内容是搜索内容还是URL，是搜索内容的话就会接合默认的搜索引擎生成URL，比如`google`浏览器是`goole.com/search?xxxx`，如果是URL会拼接协议，比如`http/https`。当页面没有监听`beforeupload`时间或者同意了继续执行流程，浏览器图标栏进入加载中的状态

接下来浏览器进程会通过`IPC`进程间通信将URL请求发送给网络进程，网络进程会先去缓存中查找该资源，如果有则拦截请求并直接200返回，没有的话进入**网络请求流程**

网络请求流程是网络进程请求`DNS`服务器返回域名对应的`IP`和端口号(如果这些之前有缓存也是直接返回缓存结果)，如果没有端口号，`http`默认为80，`https`默认为443，如果是`https`还需要建立`TLS`安全连接创建加密的数据通道

接着就是TCP三次握手建立浏览器和服务器连接，然后进行数据传输，数据传输完成四次挥手断开连接，如果设置了`connection: keep-alive`就可以一直保持连接。

网络进程将通过TCP获取的数据包进行解析，首先是响应头的content-type来判断数据类型，如果是字节流或者文件类型的话，会交给下载管理器进行下载，这时候导航流程就结束了。如果是`text/html`类型，就会通知到浏览器进程获取文档进行渲染。

浏览器进程获取到渲染的通知，会根据当前页面和新输入的页面判断是否是同一个站点，是的话就复用之前网页创建的渲染进程，否则的话会新创建一个单独的渲染进程。

浏览器进程将”提交文档“的消息给渲染进程，渲染进程接收到消息就会和网络进程建立传输数据的通道，数据传输完成后就返回”确认提交“的信息给浏览器进程。

浏览器接收到渲染进程的”确认提交“的消息后，就会更新浏览器的页面状态：安全状态、地址栏URL、前进后退的历史消息，并更新web页面，此时页面是空白页面（白屏）。

## 页面渲染过程(*)

最后是渲染进程对文档进行页面解析和子资源加载，渲染进程会将HTML转换成DOM树结构，将`css`转换成`styleSeets`(`CSSOM`)。然后复制DOM树过滤掉不显示的元素创建基本的渲染树，接着计算每个DOM节点的样式和计算每个节点的位置布局信息构建布局树

具有层叠上下文或者需要被裁剪的地方会独立创建图层，这就是分层，最终会形成一个分层树，渲染进程会给每个图层生成绘制列表并提交给合成线程，合成线程将图层分成图块(避免一次性绘制图层所有内容，可以根据图块优先需渲染视口部分)，并在光栅化线程池中将图块转换成位图

转换完毕后合成线程发送绘制图块命令`DrawQuard`给浏览器线程，浏览器根据`DrawQuard`消息生成页面，并显示在浏览器上

# TCP和UDP的区别

UDP是**用户数据包协议**（User Dataprogram Protocol），IP通过IP地址信息把数据包传送给指定电脑后，UDP可以通过端口号把数据包分给正确的程序。UDP可以校验数据是否正确，但没有重发机制，只会丢弃错误的数据包，同时UDP再发送数据之后无法确认是否到达目的地。UDP不能保证数据的可靠性，但是传输的速度非常快，通常运用于在线视频、互动游戏这些不那么严格保证数据完整性的领域。

TCP是为了解决UDP数据容易丢失，且无法正确组装数据包二引入的传输控制协议，是一种面向连接的，可靠的，基于字节流的传输层通信协议。TCP在处理数据包丢失的情况，提供了重传机制；并且TCP引入了数据包排序机制，可以将乱序的数据包组合成完整的文件。

TCP头除了包含目标端口的本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。

# 详解Content-length

Content-length是http消息长度，是十进制数字表示的字节的数目

如果Content-length > 实际长度，服务端/客户端读取到消息队尾时会继续等待下一个字节，会出现无响应超时的情况

如果Content-length < 实际长度，首次请求的消息会被截取，然后会导致后续的数据解析混乱

当不确定Content-length的值应该使用Transfer-Encoding: chunked，能够将需要返回的数据分成多个数据块，直到返回长度为0的终止块

# 跨域常用方案

## 跨域定义

协议+域名+端口号均相同时则为同域，任意一个不同则为跨域

## 解决方案

1. 传统的`jsonp`：利用`<script>`标签没有跨域限制的特点，仅支持get接口，应该没有人用这个了
2. 一般使用`cors`(跨域资源共享)来解决跨域问题，浏览器在请求头中发送origin字段指明请求发起的地址，服务端返回Access-control-allow-origin，如果一致的话就可以进行跨域访问
3. iframe解决主域名相同，子域名不同的跨域请求
4. 浏览器关闭跨域限制的功能
5. http-proxy-middleware代理

## 预检

补充：http会在跨域的时候发起一次预检请求，”需预检的请求“要求必须首先使用OPTIONS方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响

# websocket

`websocket`是一种单个建立在TCP协议上的全双工协议，它是支持双向通信的，就是服务器可以主动向客户端发消息，客户端也可以主动向服务器发消息。

它是基于HTTP协议来建立连接的，与HTTP协议的兼容性很好，所以能通过HTTP代理服务器；没有同源限制。

`WebSocket`是一种事件驱动协议，这意味着可以将其用于真正的实时通信。与HTTP不同，使用`websocket`，更新在可用时就会立即发送

当链接终止时，`websocket`不会自动恢复，这是应用开发中需要自己实现的机制，也是存在许多客服端开源库的原因之一

像`webpack`和`vite`的`devServer`就使用了`webSocket`实现热更新

# Post和Get区别

- **应用场景**

  - GET请求是一个**幂等**的请求，一般GET请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源
  - POST不是一个**幂等**的请求，一般用于对服务器资源会产生影响的场景，比如注册用户这一类的操作。

  **幂等**是指一个请求方法执行多次和仅执行一次的效果完全相同

- **是否缓存**

  浏览器一般会对GET缓存，不会对POST缓存

- **传参方式不同**

  GET通过将参数拼接到URL上进行传参，POST通过请求体传参

- **安全性**

  GET请求可以将请求的参数放入`url`中向服务器发送，这样的做法相对于POST请求来说是不太安全的，因为请求的URL会被保留在历史记录中

- **请求长度**

  浏览器由于对`url`长度限制，所以会影响GET请求发送数据时的长度。这个限制是浏览器规定的，并不是RFC规定的。

- **参数类型**

  get参数只允许ASCII字符，POST的参数传递支持更多的数据类型(如文件，图片)

# XSS 和 CSRF

## XSS基本概念

XSS(Cross site scripting)跨站脚本攻击，为了和css区别开来所以叫XSS

xss指黑客向html或dom中注入恶意脚本，从而在用户浏览页面的时候利用注入脚本对用户实施攻击的手段

恶意脚本可以做到：窃取cookie信息、监听用户行为(比如表单的输入)、修改DOM(比如伪造登录页面骗用户输入账号密码)、在页面生成浮窗广告等

**恶意脚本注入方式：**

1. 存储型xss

   黑客利用站点漏洞将恶意js代码提交到站点服务器，用户访问页面就会导致恶意脚本获取用户的cookie等信息

2. 反射型xss

   用户将一段恶意代码请求提交给web服务器，web服务器接收到请求后将恶意代码反射到浏览器端

3. 基于DOM的xss攻击

   通过网络劫持在页面传输过程中给更改HTML内容

前两种属于服务端漏洞，最后一种属于前端漏洞

## 防止xss攻击的策略

1. 服务器对输入脚本进行过滤或者转码
2. 充分利用内容安全策略CSP(content-security-policy)，可以通过http头信息的content-security-policy字段控制可以加载和执行的外部资源；或者通过html的meta标签
3. cookie设置为http-only，cookie就无法通过document.cookie来读取

## CSRF基本概念

csrf(cross site request forgery)跨站请求伪造，指黑客引导用户访问黑客的网站

CSRF是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事

## CSRF攻击场景

1. 自动发起get请求

   比如黑客网站有个图片，黑客将转账的请求接口隐藏在img标签内，欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起img的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户上的100极客币就会被转移到黑客的账户上去了

2. 自动发起post请求

   黑客在页面中构建一个隐藏的表单，当用户点开链接后，表单自动提交

3. 引诱用户点击链接

   比如页面上放了一张美女照片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的极客币就会被转到黑客账户上了

## 防止CSRF方法

1. 设置cookie时带上SameSite: strict/Lax选项
2. 验证请求的来源站点，通过origin和refere判断来源站点信息
3. CSRF token，浏览器发起请求服务器生成csrf token，发起请求前会验证csrf token是否合法。第三方网站肯定拿不到这个token。我们的csrf token是前后端约定好后写死的