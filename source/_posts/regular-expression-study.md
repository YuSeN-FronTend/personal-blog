---
title: 正则表达式
date: 2022-12-11 11:39
categories: 正则表达式
---

![](http://106.55.171.176:9000/yusen/Snipaste_2022-12-11_11-41-55.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=sttch%2F20221211%2F%2Fs3%2Faws4_request&X-Amz-Date=20221211T034314Z&X-Amz-Expires=432000&X-Amz-SignedHeaders=host&X-Amz-Signature=da3b5bd1eb6714bfa0f94c8a5ae94360f57f96ce184ea64aad305735eea524bf)

<!-- more -->

## 正则表达式的含义

正则表达式（Regular Expression）就是一们工具，目的是为了字符串模式匹配，从而实现搜索和替换功能。它起源于上个20世纪50年代科学家在数学领域做的一些研究工作，后来被引入到计算机领域中。从它的命名我们可以清晰地知道，它是一种用来描述规则的表达式。而他的底层原理也非常简单，就是使用状态机的思想进行模式匹配。

## 从字符出发

正则表达式的基本组成元素可以分为：**字符 和元字符**。字符很好理解，就是基础的计算机字符编码，通常正则表达式里面使用的就是数字、英文字母。而元字符也被称为特殊字符，是一些用来表示特殊语义的字符。如^表示非，|表示或  等等。利用这些字符，才能构造出强大的**表达式模式（pattern）**。

### 单个字符

最简单的正则表达式可以有简单的字母和数字组成。如果想在**apple**这个单词里面找到**a**这个字符，直接用`/a/`这个正则就可以。

但是如果想要匹配特殊字符的话 ，就要学习第一个元字符**/**，他是转义字符，顾名思义就是让其后续的字符失去他本来的含义。

例:我想匹配*****这个符号，但是其本身是个特殊字符，所以要利用转义字符**/**让它失去本来的含义

```javascript
/\*/
```

如果不是特殊字符，使用转义符号就会让它拥有特殊的含义。我们常常需要匹配一些特殊字符，比如空格，制表符，回车，换行等，而这些就需要我们使用转义字符来匹配。

| 特殊字符   | 正则表达式 | 记忆方式                                    |
| ---------- | ---------- | ------------------------------------------- |
| 换行符     | \n         | **n**ew line                                |
| 换页符     | \f         | **f**orm feed                               |
| 回车符     | \r         | **r**eturn                                  |
| 空白符     | \s         | **s**pace                                   |
| 制表符     | \t         | **t**ab                                     |
| 垂直制表符 | \v         | **v**ertical tab                            |
| 回退符     | [\b]       | **b**ackspace, 使用[]符号是为了避免和\b重复 |

### 多个字符

单个字符的映射关系是一对一的，即正则表达式的被用来筛选匹配的字符只有一个，而这显然是不够的，只要引入集合区间和通配符的方式就可以实现一对多的匹配了。

在正则表达式里，集合的定义方式是通过使用中括号[]。如`/[123]/`这个正则就能同时匹配1，2，3三个字符。元字符**-**可以表示区间范围，例如`/[0-9]/`可以匹配所有数字。`/[a-z]/`可以匹配所有的小写字母。

为了方便，正则表达式衍生了一批用来同时匹配多个字符的简便正则表达式。

| 匹配区间                                       | 正则表达式 | 记忆方式             |
| ---------------------------------------------- | ---------- | -------------------- |
| 除了换行符之外的任何字符                       | .          | 句号，除了句子结束符 |
| 单个数字，[0-9]                                | \d         | **d**igit            |
| 除了[0-9]                                      | \D         | **not d**igit        |
| 包括下划线在内的单个字符，[A-Za-z0-9]          | \w         | **w**ord             |
| 非单字字符                                     | \W         | **not w**ord         |
| 匹配空白字符，包括空格，制表符，换页符和换行符 | \s         | **s**pace            |
| 匹配非空白字符                                 | \S         | **not s**pace        |

### 循环与重复

多个字符的匹配需要多次循环

#### 0|1

元字符**?**代表了匹配一个字符或0个字符。设想一下，如果你要匹配color和colour这两个单词，就需要同时保证**u**这个字符是否出现都能被匹配到。所以可以这样书写正则表达式：`/colou?r/`。

#### >=0

元字符*****用来匹配0个或无数个字符。通常用来过滤某些可有可无的字符串。

#### >=1

元字符**+**适用于要匹配同个字符出现1次或多次的情况。

#### 特定次数

在一些情况下，我们需要指定重复次数。元字符**{}**可以设置精确的区间范围。如'a'我想匹配三次，可以使用`/a{3}/`，或者'a'我想匹配至少两次就是用`/a{2,}/`这个正则。

完整语法：

```
- {x}: x次
- {min, max}: 介于min次到max次之间
- {min, }: 至少min次
- {0, max}: 至多max次
```

### 位置边界

在长文本字符串查找过程中，我们常常需要限制查询的位置。比如我只想在单词的开头结尾查找。

#### 单词边界

例：

```
The cat scattered his food all over the room.
```

我想找cat这个单词，如果使用 `/cat/`这个正则，或匹配到cat和scattered两处文本，所以我们要用到边界正则表达式`\b`，所以将上面例子改成`/\bcat\b/`就能匹配到cat这个单词了。

#### 字符串边界

元字符**^**用来匹配字符串的开头。元字符**$**用来匹配字符串的末尾。如若排除换行符干扰，我们要使用多行模式。

```
I am scq000.
I am scq000.
I am scq000.
```

我们可以使用`/^ I am scq000\.$/m`这样的正则表达式，其实m是multiple line的首字母。正则中除了m外，比较常用的还有i和g。前者是忽略大小写，后者是找到所有符合的匹配**（全局匹配）**。

总结：

| 边界和标志 | 正则表达式 | 记忆方式                              |
| ---------- | ---------- | ------------------------------------- |
| 单词边界   | \b         | **b**oundary                          |
| 非单词边界 | \B         | **not b**oundary                      |
| 字符串开头 | ^          | 小**头尖尖**                          |
| 字符串结尾 | $          | 拿**$**收尾                           |
| 多行模式   | m标志      | **m**ultiple of lines                 |
| 忽略大小写 | i标志      | **i**gnore case, case-**i**nsensitive |
| 全局模式   | g标志      | **g**lobal                            |

### 子表达式

子表达式是通过嵌套递归和自身引用可以让正则发挥更强大的功能。

从简单到复杂的正则表达式演变通常要采用**分组、回溯引用和逻辑处理**的思想。利用这三种规则，可以推演出无限复杂的正则表达式。

#### 分组

其中分组体现在：所有以**()**元字符所包含的正则表达式被分为一组，每一个分组都是一个子表达式。它是构成高级正则表达式的基础。想要让它发挥强大的作用，往往要结合回溯引用的方法。

#### 回溯引用

所谓回溯引用指的是模式的后面部分引用前面已经匹配到的子字符串。

假设现在要在下面例子中匹配两个连续相同的单词

```
Hello what what is the first thing, and I am am scq000.
```

利用回溯引用可以很容易得到`\b(\w+)\s\1`这样的正则。

回溯引用在替换字符串中非常常用，语法上有些许区别，用$1,$2...来引用要被替换的字符串。

```js
var str = 'abc abc 123';
str.replace(/(ab)c/g,'$1g');
// 得到结果 'abg abg 123'
```

如果不想子表达式被引用，可以使用**非捕获**正则`(?:regex)`这样就可以避免浪费内存。

```js
var str = 'scq000'.
str.replace(/(scq00)(?:0)/, '$1,$2')
// 返回scq00,$2
// 由于使用了非捕获正则，所以第二个引用没有值，这里直接替换为$2
```

有时我们需要限制回溯引用的适用范围。那么通过向前查找和向后查找就可以达到这个目的。

#### 前向查找

前向查找是用来限制后缀的。例如 **happy happily**这两个单词，我想获得以**happ**开头的副词，就可以用 `happ(?=ily)`来匹配。如果想过滤**happ**开头的副词，一可以采用**负前向查找**的正则**happ(?!ily)**，就会匹配到happy单词的happ前缀。

#### 后向查找

其中`(?<=regex)`的语法就是我们这里要介绍的后向查找。`regex`指代的子表达式会作为限制项进行匹配，匹配到这个子表达式后，就会继续向**后**查找。另外一种限制匹配是利用`(?<!regex)` 语法，这里称为**负后向查找**。与正前向查找不同的是，被指定的子表达式不能被匹配到。于是，在上面的例子中，如果想要查找`apple`的`ple`也可以这么写成`/(?<!peo)ple`。

**ps：从es2018之后，js支持后向查找，但部分浏览器还需注意兼容问题。**

总结：

| 回溯查找   | 正则                 | 记忆方式                                                     |
| ---------- | -------------------- | ------------------------------------------------------------ |
| 引用       | \0,\1,\2 和 $0,$1,$2 | 转义+数字                                                    |
| 非捕获组   | (?:)                 | 引用表达式(()),本身不被消费(?),引用(:)                       |
| 前向查找   | (?=)                 | 引用子表达式(())，本身不被消费(?), 正向的查找(=)             |
| 前向负查找 | (?!)                 | 引用子表达式(())，本身不被消费(?), 负向的查找(!)             |
| 后向查找   | (?<=)                | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，正的查找(=) |
| 后向复查找 | (?<!)                | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，负的查找(!) |

### 逻辑处理

计算机科学是一门包含逻辑的科学。让我们来回忆一下编程语言当中用到的三种逻辑关系，与或非。

- 默认的正则规则都是**与**。
- **非**分为两种情况：一种是字符匹配，另一种是子表达式匹配。在字符匹配时需要使用**^**这个元字符。注：**只有在[]内部使用的^才表示非的关系。**子表达式匹配的**非**关系就要用到前面介绍的前向负查找子表达式**(?!regex)**或后向负查找子表达式方法(?>!regex)。
- **或**关系，通常给子表达式进行归类使用。比如我想同时匹配a,b两种情况就可以使用(a|b)这样的子表达式。

| 逻辑关系 | 正则元字符  |
| -------- | ----------- |
| 与       | 无          |
| 或       | [^regex]和! |
| 或       | \|          |





